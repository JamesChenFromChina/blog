#+TITLE: C++11学习笔记
#+DATE: 2017-08-11
#+LAYOUT: post
#+TAGS: C++ C++11 cpp
#+CATEGORIES: C++



* constexpr常量表达式
   两种使用方式
   1. 使用在常亮声明前,把常量存储在静态存储区，提高安全性。
   2. 使用在函数声明和定义前，制定常量表达式，在函数的所有参数均为常量表达式的时候函数返回一个常量表达式，如果参数非均为常量，则像普通函数一样工作避免了重复定义。 
   3. 示例如下：
      
#+BEGIN_SRC cpp
constexpr int TestFun(int testval);

constexpr int TestFun(int testval) {
    return testval * 2;
}

constexpr int TestVal = TestFun(2);
#+END_SRC

* alignof(expression) alignas(type or expression)
   alignof 和 alignas用于内存对齐,提供了更灵活的操作，由于该操作之前在各个系统中基本都有实现,这里做了统一.注意alignas的参数必须是类型或者2的n次幂。

#+BEGIN_SRC cpp
    constexpr int bufmax = 1024;
    char buffer1[bufmax];
    alignas(int) char buffer2[bufmax];  //对齐到 sizeof（int） 倍
    alignas(8) char buffer3[bufmax];    //对齐到8的整数倍
    // alignas(3) char buffer3[bufmax];    //编译错误，必须对齐到2的n次幂

    auto ai1 = alignof(buffer1); // ai1 的推断结果为 m 类型 unsigned long
    auto ai2 = alignof(buffer2);
    auto ai3 = alignof(buffer3);

    cout<<"alignof(buffer) : "<<ai1<<endl
        <<"and ai type is : "<<typeid(ai1).name()<<endl
        <<"buffer addr : 0x"<<ios_base::hex<<reinterpret_cast<uint64_t>(buffer1)<<endl
        <<"alignof(buffer2) : "<<ai2<<endl
        <<"buffer2 addr : 0x"<<ios_base::hex<<reinterpret_cast<uint64_t>(buffer2)<<endl
        <<"type name int : "<<typeid(bufmax).name()<<endl;
#+END_SRC

* Using　声明别名
   using和typedef的使用在类型声明上基本一致，但是ｔｙｐｅｄｅｆ无法使用在模板定义中

#+BEGIN_SRC cpp

template <typename T>
class TestUsing
{
    typedef T value_type;
   public:
    T add(T a, T b) { return a + b; }
};

template <typename T>
using NewName = TestUsing<T>;

typedef TestUsing<int> NewName2;

// template <typename T>
// typedef TestUsing<T> NewName2;  //编译错误　ｔｙｐｅｄｅｆ不可用于模板, 即定义出的新类型不能使模板。

#+END_SRC

* 初始化
** 初始化器的四种格式
   1. X a1{v}; //列表初始化
   2. X a2 = {v}; //列表初始化
   3. X a3 = v;
   4. X a4(v);
** 列表初始化可以防止窄化转换，这意味着
  1. 整型和浮点型数据不会向存不下它的方向转化 例如float=>double double!=>float char=>int int!=>char
  2. 整型和浮点型两种类型的数据不能相互转化 float!=>int int!=>float
** 使用ａｕｔｏ声明的对象不应该使用列表初始化，因为类型推断的结果可能是　ｉｎｉｔｉａｌｉｚｅｒ_list<T> (在初始化参数是列表的情况下）
** 使用空列表初始化会使用默认值对对象进行初始化，一般是0值，指针是　ｎｕｌｌｐｔｒ
*** char buffer[len]{} 将会把buffer中所有的变量初始化成 0 在buffer很大的时候可能会产生性能影响
      
** 如果变量没有指定初始化器则
   1. 全局变量、名字空间变量、局部static变量和static成员（统称为静态对象）将会执行相应数据类型的列表{}初始化
   2. 对于局部变量和自由存储上的对象（堆对象）将会使用默认构造函数(是用户自定义类型且存在默认构造函数)或不执行默认初始化（语言内置类型）
       
** 推断类型： auto和decltype（）
   c++提供了两种从表达式推断数据类型的机制，从编译器返回一个已知的表达式结果的类型
   1. auto 根据对象的初始化器推断对象的数据类型，对象可能是变量、const或constexpr
   2. decltype（expr） 推断的对象可能是函数的返回值的类型、类成员的类型和变量的类型
       
*** auto 的使用
    1. auto可以作为初始化器类型的占位符，避免冗余的书写
    2. auto可以抽象函数中的类型信息，在对象的类型发生变化的时候一定程度上避免函数逻辑受影响，例如 vector类型替换成list类型的迭代循环工作，当然在较大范围内使用auto会影响代码可读性和提高错误定位的难度。
*** 类型推断
     1. 我们可以为推断出的类型增加类型说明符和修饰符，比如&或const
     2. 由于引用类型会自动解引用，所以推断出的类型永远不会是引用类型
       
#+BEGIN_SRC cpp
auto const testValA = 100;
auto constexpr testValB = 100;

int main(int argc, char *argv[])
{
    cout << "type name : " << typeid(decltype(testValA)).name() << endl;
    auto x = decltype(testValA){10};
    cout << "type name : " << typeid(decltype(x + 100)).name()
         << " the value is " << x << endl;

    int a = 100;
    int &ra = a;
    auto autora = ra;
    cout << "Is lvalue reference: " << is_lvalue_reference<decltype(autora)>::value << endl;
    auto &autorra = ra;
    cout << "Is lvalue reference: " << is_lvalue_reference<decltype(autorra)>::value << endl;

    // auto autoval{100, 200, 300}; //error :  direct-list-initialization of ‘auto’ requires exactly one element [-fpermissive]

    auto autoval1{100};
    cout<<"type of autoval1 : "<<typeid(autoval1).name()<<endl;  // i
    auto autoval2 = {100};
    cout<<"type of autoval2 : "<<typeid(autoval2).name()<<endl;  // St16initializer_listIiE
    auto autoval3 = {100, 200, 300};
    cout << "type of autoval3 : " << typeid(autoval3).name() << endl; // St16initializer_listIiE


}
#+END_SRC

** 左值和右值
   对变量分类的两种属性
   i: 有身份 在程序中有对象的名字或者存在指针\引用指向该对象， 这样我们可以在后面找到它
   m: 可移动 能把对象移动出来（要看之后还会不会使用它,剩下的对象处于合法但未指定的状态）
   根据这两种属性可以将对象分成
   i => 泛左值
   i&!m => 左值
   m => 右值
   !i&m => 纯右值
   i&m => 特别值
   
** 对象生命周期
   构造函数结束-》析构函数执行
   分类：
   1. 自动对象:在函数中声明的对象，再起定义处被创建，超出作用域后销毁，大多数实现中存储在栈帧中
   2. 静态对象:在全局作用域、名字空间作用域中声明或在函数或类中以static声明的对象，整个程序运行过程中只被初始化一次，生命周期持续到程序结束，在程序执行过程中地址唯一
   3. 自由存储对象：通过new和delete直接控制生命周期的对象
   4. 临时对象：在计算中间结果或存放const实参引用的值的对象，生命周期视具体情况而定，如果该对象被绑定到一个引用上，则生命周期与该引用一致，否则与它所处的完整表达式一致
   5. 线程局部对象：声明为thread_local的对象随着线程的创建而创建，随着线程的销毁而销毁。
   数组元素和非静态类成员的生命周期由他们所属的对象决定
   
* 类型别名
  
   
* 小细节
  抽象函数的调用需要使用指针或引用操作对象的主要原因是执行抽象任务的代码无法判断对象属于那个具体的实现，所以编译器对操作对象需要的空间大小一无所知，无法从栈上分配合理的空间。
  每个含有虚函数的类都含有自己的vtbl用于虚函数的调用，虚函数的调用会抽象成对vtbl指定索引的函数的调用。
