#+TITLE: C++11学习笔记
#+DATE: 2017-08-11
#+LAYOUT: post
#+TAGS: C++ C++11 cpp
#+CATEGORIES: C++


* CppReference
  [[http://en.cppreference.com/][CppReference]] 

* constexpr常量表达式
   两种使用方式
   1. 使用在常量声明前,把常量存储在静态存储区，提高安全性。
   2. 使用在函数声明和定义前，制定常量表达式，在函数的所有参数均为常量表达式的时候函数返回一个常量表达式，如果参数非均为常量，则像普通函数一样工作避免了重复定义。 
   3. 示例如下：
      
#+BEGIN_SRC cpp
constexpr int TestFun(int testval);

constexpr int TestFun(int testval) {
    return testval * 2;
}

constexpr int TestVal = TestFun(2);
#+END_SRC

* alignof(expression) alignas(type or expression)
   alignof 和 alignas用于内存对齐,提供了更灵活的操作，由于该操作之前在各个系统中基本都有实现,这里做了统一.注意alignas的参数必须是类型或者2的n次幂。

#+BEGIN_SRC cpp
    constexpr int bufmax = 1024;
    char buffer1[bufmax];
    alignas(int) char buffer2[bufmax];  //对齐到 sizeof（int） 倍
    alignas(8) char buffer3[bufmax];    //对齐到8的整数倍
    // alignas(3) char buffer3[bufmax];    //编译错误，必须对齐到2的n次幂

    auto ai1 = alignof(buffer1); // ai1 的推断结果为 m 类型 unsigned long
    auto ai2 = alignof(buffer2);
    auto ai3 = alignof(buffer3);

    cout<<"alignof(buffer) : "<<ai1<<endl
        <<"and ai type is : "<<typeid(ai1).name()<<endl
        <<"buffer addr : 0x"<<ios_base::hex<<reinterpret_cast<uint64_t>(buffer1)<<endl
        <<"alignof(buffer2) : "<<ai2<<endl
        <<"buffer2 addr : 0x"<<ios_base::hex<<reinterpret_cast<uint64_t>(buffer2)<<endl
        <<"type name int : "<<typeid(bufmax).name()<<endl;
#+END_SRC

* Using　声明别名
   using和typedef的使用在类型声明上基本一致，但是ｔｙｐｅｄｅｆ无法使用在模板定义中
   一般_t后缀表示该类型是另一个类型的别名

#+BEGIN_SRC cpp
template <typename T>
class TestUsing
{
    typedef T value_type;
   public:
    T add(T a, T b) { return a + b; }
};

template <typename T>
using NewName = TestUsing<T>;
typedef TestUsing<int> NewName2;
// template <typename T>
// typedef TestUsing<T> NewName2;  //编译错误　ｔｙｐｅｄｅｆ不可用于模板, 即定义出的新类型不能使模板。 
#+END_SRC

   *注意:不允许在类型别名前加修饰符（如ｕｎｓｉｇｎｅｄ）*
   
#+BEGIN_SRC cpp
using Char2 = char;
unsigned Char2 testval; //(BE147) error: expected initializer before ‘testval’ 
#+END_SRC

* 初始化
** 初始化器的四种格式
   1. X a1{v}; //列表初始化
   2. X a2 = {v}; //列表初始化
   3. X a3 = v;
   4. X a4(v);
** 列表初始化可以防止窄化转换，这意味着
  1. 整型和浮点型数据不会向存不下它的方向转化 例如float=>double double!=>float char=>int int!=>char
  2. 整型和浮点型两种类型的数据不能相互转化 float!=>int int!=>float
** 使用ａｕｔｏ声明的对象不应该使用列表初始化，因为类型推断的结果可能是　ｉｎｉｔｉａｌｉｚｅｒ_list<T> (在初始化参数是列表的情况下）
** 使用空列表初始化会使用默认值对对象进行初始化，一般是0值，指针是　ｎｕｌｌｐｔｒ
*** char buffer[len]{} 将会把buffer中所有的变量初始化成 0 在buffer很大的时候可能会产生性能影响
      
** 如果变量没有指定初始化器则
   1. 全局变量、名字空间变量、局部static变量和static成员（统称为静态对象）将会执行相应数据类型的列表{}初始化
   2. 对于局部变量和自由存储上的对象（堆对象）将会使用默认构造函数(是用户自定义类型且存在默认构造函数)或不执行默认初始化（语言内置类型）
       
** 推断类型： auto和decltype（）
   c++提供了两种从表达式推断数据类型的机制，从编译器返回一个已知的表达式结果的类型
   1. auto 根据对象的初始化器推断对象的数据类型，对象可能是变量、const或constexpr
   2. decltype（expr） 推断的对象可能是函数的返回值的类型、类成员的类型和变量的类型
       
*** auto 的使用
    1. auto可以作为初始化器类型的占位符，避免冗余的书写
    2. auto可以抽象函数中的类型信息，在对象的类型发生变化的时候一定程度上避免函数逻辑受影响，例如 vector类型替换成list类型的迭代循环工作，当然在较大范围内使用auto会影响代码可读性和提高错误定位的难度。
*** 类型推断
     1. 我们可以为推断出的类型增加类型说明符和修饰符，比如&或const
     2. 由于引用类型会自动解引用，所以推断出的类型永远不会是引用类型
       
#+BEGIN_SRC cpp
auto const testValA = 100;
auto constexpr testValB = 100;

int main(int argc, char *argv[]) {
    cout << "type name : " << typeid(decltype(testValA)).name() << endl;
    auto x = decltype(testValA){10};
    cout << "type name : " << typeid(decltype(x + 100)).name()
         << " the value is " << x << endl;
    int a = 100;
    int &ra = a;
    auto autora = ra;
    cout << "Is lvalue reference: " << is_lvalue_reference<decltype(autora)>::value << endl;
    auto &autorra = ra;
    cout << "Is lvalue reference: " << is_lvalue_reference<decltype(autorra)>::value << endl;
    // auto autoval{100, 200, 300}; //error :  direct-list-initialization of ‘auto’ requires exactly one element [-fpermissive]
    auto autoval1{100};
    cout<<"type of autoval1 : "<<typeid(autoval1).name()<<endl;  // i
    auto autoval2 = {100};
    cout<<"type of autoval2 : "<<typeid(autoval2).name()<<endl;  // St16initializer_listIiE
    auto autoval3 = {100, 200, 300};
    cout << "type of autoval3 : " << typeid(autoval3).name() << endl; // St16initializer_listIiE
}
#+END_SRC

** 左值和右值
   对变量分类的两种属性
   * i: 有身份 在程序中有对象的名字或者存在指针\引用指向该对象， 这样我们可以在后面找到它
   * m: 可移动 能把对象移动出来（要看之后还会不会使用它,剩下的对象处于合法但未指定的状态）
     

   根据这两种属性可以将对象分成
   * i => 泛左值
   * i&!m => 左值
   * m => 右值
   * !i&m => 纯右值
   * i&m => 特别值
   
** 对象生命周期
   * 构造函数结束-》析构函数执行
   * 分类：
     1. 自动对象:在函数中声明的对象，再起定义处被创建，超出作用域后销毁，大多数实现中存储在栈帧中
     2. 静态对象:在全局作用域、名字空间作用域中声明或在函数或类中以static声明的对象，整个程序运行过程中只被初始化一次，生命周期持续到程序结束，在程序执行过程中地址唯一
     3. 自由存储对象：通过new和delete直接控制生命周期的对象
     4. 临时对象：在计算中间结果或存放const实参引用的值的对象，生命周期视具体情况而定，如果该对象被绑定到一个引用上，则生命周期与该引用一致，否则与它所处的完整表达式一致
     5. 线程局部对象：声明为thread_local的对象随着线程的创建而创建，随着线程的销毁而销毁。

   * 数组元素和非静态类成员的生命周期由他们所属的对象决定
   
* 指针、数组与引用
** 指针
  * *注意无法将函数指针赋予ｖｏｉｄ类型的指针*
  * *想要使用ｖｏｉｄ指针必须先把它转换成其他类型的指针* ,否则编译器不知道如何处理, 包括解引用和 ++
  * nullptr值只能被赋予指针，不能被赋予数值类型，从而增加了安全性,尤其是当一组重载函数同一参数位置即可以接收整数参数也可以接收指针类型参数的时候不容易出现歧义
  
#+BEGIN_SRC cpp
int testPtr() {
    void (*userfun)(const vector<int> &) = user;
    void *testPtr = userfun; //error: invalid conversion from ‘void (*)(const std::vector<int>&)’ to ‘void*’ [-fpermissive]
    int *test = (int *)0; // 合法但是无法为每种类型实现一个NULL 所以c++中的指针实现为 0 或 0L
    int *test = (int *)123; // 这个表达式合法 但是int *test = 123; 不合法不存在合理的类型转换123是整型字面量
    // int *test = (void *)0; // 在C++中不合法，所以C++中的NULL实现为0 或 0L 但是c中的NULL实现为(void *)0
    
    int a = 100;
    int *pa = &a;
    const int *pa1 = &a;
    // *pa1 = 200; // error: assignment of read-only location ‘* pa1’  //指向的值是常量
    int const *pa2 = &a;
    // *pa2 = 300; // error: assignment of read-only location ‘* pa2’  //指向的值是常量
    pa2 = pa;
    int *const pa3 = &a;
    *pa3 = 400;
    pa3 = pa; // error: assignment of read-only variable ‘pa3’ //指针本身是常量
}    
#+END_SRC
** 数组
  * 申请非自由存储对象数组的时候数组的长度必须是常量表达式（否则编译器无法确定在栈上或者静态存储区上分配内存空间的大小）
  * 注意在作为参数传递数组的时候形参即使写成数组形式，实际上也会被转换成相应的指针，sizeof的结果会有所不同，所以尽量避免使用数组类型的形参
  * 假设存在内置数组a和数组有效范围内的整数j则以下表达式等效
    * a[j] == *(&a[0]+j) == *(a+j) = *(j+a) = j[a]
    * 注意j[a]
  
#+BEGIN_SRC cpp
int testArrayParam(uint8_t ta[100]) {
    cout<<"sizeof(ta) in fun:"<<sizeof(ta)<<" typeid(ta):"<<typeid(ta).name()<<endl;
    // sizeof(ta) in fun:8 typeid(ta):Ph
    return ta[0];
}
int main(int argc, char *argv[]) {
    uint8_t testArray[100];
    uint8_t testArray2[100];
    // testArray2 = testArray; // error: invalid array assignment
    // uint8_t &rtestArray[100] = testArray; // error: declaration of ‘rtestArray’ as array of references
    // uint8_t (&rtestArray)[] = testArray; // error: invalid initialization of reference of type ‘uint8_t (&)[] {aka unsigned char (&)[]}’ from expression of type ‘uint8_t [100] {aka unsigned char [100]}’
    uint8_t (&rtestArray)[100] = testArray;
    cout<<"sizeof(ta) in main:"<<sizeof(rtestArray)<<" typeid(ta):"<<typeid(rtestArray).name()<<endl;
    // sizeof(ta) in main:100 typeid(ta):A100_h
    testArrayParam(rtestArray);
    // uint32_t intArray[2] = {1, 2, 3}; // error: too many initializers for ‘uint32_t [2] {aka unsigned int [2]}’

    char testA[] = "abcd";
    3[testA] = 'f'; // 不要惊讶 合法。
    cout<<testA<<endl; // abcf

}

#+END_SRC

*** 指针数组和多维数组的小细节
    * 二维数组在函数参数传递的时候必须要附带一维的大小，否则编译器会报错。
    * 指针在进行二维索引的时候 p[x][y] 实际上是做 *(*(p+x)+y)操作，这也说明了为什么二维数组指针需要携带一维维度


#+BEGIN_SRC cpp

    int testAA[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    int testPA1[] = {1, 2, 3};
    int testPA2[] = {4, 5, 6};
    int testPA3[] = {7, 8, 9};
    int *testPA[] = { testPA1, testPA2, testPA3 };

    cout<<"dump testAA[i]"<<endl;
    for (int i = 0; i != 9; ++i)
        cout<<" i : "<<i<<" val : "<<testAA[i]<<endl;

    cout<<"dump testPA[i]"<<endl;
    for (int i = 0; i != 3; ++i)
        cout << "i : " << i << " val : " << testPA[i] << endl;
/*
dump testAA[i]
 i : 0 val : 0x7ffea9337120
 i : 1 val : 0x7ffea933712c
 i : 2 val : 0x7ffea9337138
 i : 3 val : 0x7ffea9337144
 i : 4 val : 0x7ffea9337150
 i : 5 val : 0x7ffea933715c
 i : 6 val : 0x7ffea9337168
 i : 7 val : 0x7ffea9337174
 i : 8 val : 0x7ffea9337180
dump testPA[i]
i : 0 val : 0x7ffea93370d0
i : 1 val : 0x7ffea93370e0
i : 2 val : 0x7ffea93370f0
*/

void testArray2(int (*pArray)[3]) { return ; }
void testArray3(int **pArray) { return; }
int testArray1() {
    int testAA[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; //这里数组间都插入了4个字节的缝隙，对齐到了16字节，不知道具体原因
    int testPA1[] = {1, 2, 3};
    int testPA2[] = {4, 5, 6};
    int testPA3[] = {7, 8, 9};
    int *testPA[] = { testPA1, testPA2, testPA3 };

    testArray2(testAA);
    // testArray3(testAA); // error: cannot convert ‘int (*)[3]’ to ‘int**’ for argument ‘1’ to ‘void testArray3(int**)’
    // testArray2(testPA); // error: cannot convert ‘int**’ to ‘int (*)[3]’ for argument ‘1’ to ‘void testArray2(int (*)[3])’
    testArray3(testPA);
    
    int test[2][3];
    // int *p = test; // error: cannot convert ‘int (*)[3]’ to ‘int*’ in initialization
    // p[x][y] 执行的操作是 *(*(p+x)+y)
    int *p = test[0];
    p[3*1+2] = 1; // test[1][2]; // 对于二维数组也许这样是正确的打开方式, 明显容易出现歧义
}

#+END_SRC

*** 字符串
**** 字面值
    一个很大的变化是字符串字面值在C++11中是const char* 而且可能被存贮到了只读段，这意味这对字面值常量的修改会造成段错误。标准中使用char*指针接收字面值常量会引发编译错误gcc实现中允许了这种操作.
   
 #+BEGIN_SRC cpp
 int testStr() {
     char *str = "test string"; // warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings] 之前的版本是合法的c++11要求必须为 const char*
     str[2] = 'a';    // 这里在gcc version 5.4.0中崩溃了，应该是字符串字面值被存储到了只读存储区
     char strWritable[] = "test string"; //可修改 但是注意生命周期和上面的不同
 }
 #+END_SRC

**** 原始字符串
     由于一些类似正则表达式这样的需求，有时候需要频繁在字符串中插入\或者"，在这种情况下原本的字符串常量书写变得十分复杂，原始字符串可以在字面量中插入\和"等字符，而不做特殊解释,简化了相关字符串的输入，在需要输入诸如）"这样的字符串序列的时候可以在引号和括号间插入若干字符序列，起到构造字符串字面量的作用，如下面rawStr2所示。

 #+BEGIN_SRC cpp
 int testStr() {
     const char *rawStr = R"(abcx123\\ "")"; // 原始字符串，转移符和引号按正常字符打印可以插入换行
     const char *rawStr2 = R"*ab(abcx123\\ "")*ab"; // 这里需要注意 "(...)" 格式的原始字符串字面量要求前面的*ab和后面的*ab需要匹配，序列被插入到了引号和括号之间，以避免结束部分和字符串内容重叠 
 }
 #+END_SRC

**** 大字符
    * 前缀L表示宽字符字面值，通过wchar_t存储，但是编码格式依赖于编译器和具体环境

***** unicode编码字符串常量
      * 类型
        1. u8表示使用 unicode8 格式进行编码 (无法用于 u8''，因为可能存储不下？)
        2. u表示使用 unicode16 格式进行编码
        3. U表示使用 unicode32 格式进行编码
      * *注意*
        * 前缀u和R是有序且区分大小写的
        * 前缀u实际上已经透露了存储类型（char char16_t char32_t),所以无法同时使用L限定，而且使用的存储类型也不能和wchar_t混用
   
  #+BEGIN_SRC cpp
  int testStr() {
      const char *testc = "testc";
      const char *testu8 = u8"testu8";
      const char *testu8r = u8R"(testu8r)";
      // const char *testu = u"testu"; // error: cannot convert ‘const char16_t*’ to ‘const char*’ in initialization
      // const wchar_t *testu1 = u"testu"; // error: cannot convert ‘const char16_t*’ to ‘const wchar_t*’ in initialization
      const wchar_t *testw = L"testw";
      // const char16_t *testwc16 = testw; // error: cannot convert ‘const wchar_t*’ to ‘const char16_t*’ in initialization

      const char16_t *testu = u"testu";
      const char32_t *testU = U"testU";
      // const char16_t *testlu = Lu"testu"; // ‘Lu’ was not declared in this scope
      // const char16_t *testul = uL"testu"; // ‘uL’ was not declared in this scope
      const char16_t *testuR = uR"(testuR)";
  }
  #+END_SRC

** 引用
*** 引用的作用
    1. 不存在空引用或未初始化的引用，因此在代码中可以充当对象的别名，一直指向最开始初始化的那个对象
    2. 语法形式和对象操作相同便于实现运算符重载 （避免了 &x+&y 这种诡异形式）
    3. 和指针一样存储地址，没有其他额外开销
*** 引用的分类
    | 类型          | 说明                   |
    |---------------+------------------------|
    | 左值引用      | 可以改变值的对象       |
    | 左值const引用 | 不可以改变值的对象     |
    | 右值引用      | 在使用后无需保留的对象 |
    |---------------+------------------------|

*** 左值引用

* 小细节
  * 抽象函数的调用需要使用指针或引用操作对象的主要原因是执行抽象任务的代码无法判断对象属于那个具体的实现，所以编译器对操作对象需要的空间大小一无所知，无法从栈上分配合理的空间。
  * 每个含有虚函数的类都含有自己的vtbl用于虚函数的调用，虚函数的调用会抽象成对vtbl指定索引的函数的调用。
  * 用const定义的常量必须在声明的时候初始化，因为后面无法再对其进行赋值
#+BEGIN_SRC cpp
    // const int a; // error: uninitialized const ‘a’ [-fpermissive]
#+END_SRC
